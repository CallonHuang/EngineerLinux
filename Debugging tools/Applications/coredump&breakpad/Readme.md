# 从 *coredump* 到 *breakpad*

### Content

- [简介](#简介)

- [*coredump* 使用](#coredump-使用)
- [*breakpad* 使用](#breakpad-使用)
  - [*breakpad* 编译](#breakpad-编译)
  - [*breakpad* 应用实例](#breakpad-应用实例)

---

### 简介

目前针对难复现疑难问题，比较好的方法依然是部署 *coredump*，这是一种可以将崩溃时进程的内存和寄存器相关信息全部 *dump* 的内核技术，它需要配合 *gdb* 进行解析，可以将完整的调用栈以及每个调用栈相关的寄存器和变量值都展现出来。

但是其在嵌入式领域却鲜少默认放开，原因无非两点：

1. 由于其 *dump* 的信息很充分，造成 *coredump* 文件非常之大，即使压缩了，嵌入式设备上也很难存多份这种信息；
2. *coredump* 文件很容易损坏/存在调用栈被破坏的情况，这种情况下，即使是经验非常丰富的开发人员，最终只能凭经验查看寄存器值进行猜测。

因此，*google* 推出了 *breakpad* 针对这两点进行了有效的优化。

---

### *coredump* 使用

#### *coredump* 环境设置

为了保证 *coredump* 的正常生成，需要在目标用户程序启动之前，使用如下类似脚本进行环境设置（当然，前提还需要内核支持）：

```shell
#!/bin/sh
echo "set coredump env..."
ulimit -c unlimited
echo 1 > /proc/sys/kernel/core_uses_pid
mkdir -p /var/syslog/coredump/
echo "| /usr/bin/corehelper %E %p %t" > /proc/sys/kernel/core_pattern
```

其中，关于 `core_pattern` 的 *format* 设置有如下几个常用选项：

> %p：pid
>
> %e：executable filename
>
> %t：UNIX time of dump
>
> %s：signal number

而 `corehelper` 也是个脚本，用于配置 *coredump* 的压缩以减少 *core* 文件的大小：

```shell
#!/bin/sh
exec gzip ->/var/syslog/coredump/$1-$2-$3.core.gz
```

#### *coredump* 应用实例

> 注：本例由于是在centos虚拟机下进行测试的，所以环境设置的操作略有不同。

1. 产生 *core* 文件

   ```shell
   [root@be0ed8be6b49 test]# ls
   main.c
   [root@be0ed8be6b49 test]# cat main.c
   #include <stdio.h>
   #include <stdlib.h>
   
   int main()
   {
   	int *ptr = NULL;
   	printf("ptr = %d\n", *ptr);
   	return 0;
   }
   [root@be0ed8be6b49 test]# gcc -g main.c -o main
   [root@be0ed8be6b49 test]# ls
   main  main.c
   [root@be0ed8be6b49 test]# ulimit -c unlimited
   [root@be0ed8be6b49 test]# ./main
   Segmentation fault (core dumped)
   [root@be0ed8be6b49 test]# ls
   core  main  main.c
   [root@be0ed8be6b49 test]#
   ```

   默认 *core* 文件一般都产生在程序所在目录

2. *core* 文件的使用

   ```shell
   [root@be0ed8be6b49 test]# gdb main core
   GNU gdb (GDB) Red Hat Enterprise Linux 8.2-15.el8
   Copyright (C) 2018 Free Software Foundation, Inc.
   ...
   Reading symbols from main...done.
   [New LWP 91]
   Core was generated by `./main'.
   Program terminated with signal SIGSEGV, Segmentation fault.
   #0  0x00000000004005aa in main () at main.c:7
   7		printf("ptr = %d\n", *ptr);
   Missing separate debuginfos, use: yum debuginfo-install glibc-2.28-127.el8.x86_64
   (gdb) bt
   #0  0x00000000004005aa in main () at main.c:7
   (gdb) info locals
   ptr = 0x0
   (gdb) info registers
   rax            0x0                 0
   rbx            0x0                 0
   rcx            0x7fefe85bb738      140668372236088
   rdx            0x7fff384ddcd8      140734138014936
   rsi            0x7fff384ddcc8      140734138014920
   rdi            0x1                 1
   rbp            0x7fff384ddbe0      0x7fff384ddbe0
   rsp            0x7fff384ddbd0      0x7fff384ddbd0
   r8             0x7fefe85bcce0      140668372241632
   r9             0x7fefe85bcce0      140668372241632
   r10            0x0                 0
   r11            0x0                 0
   r12            0x4004b0            4195504
   r13            0x7fff384ddcc0      140734138014912
   r14            0x0                 0
   r15            0x0                 0
   rip            0x4005aa            0x4005aa <main+20>
   eflags         0x10202             [ IF RF ]
   cs             0x33                51
   ss             0x2b                43
   ds             0x0                 0
   es             0x0                 0
   fs             0x0                 0
   gs             0x0                 0
   (gdb)
   ```

如果是在嵌入式设备上，一般调试 *core* 的过程是在服务器上的，这种情况下由于程序可能依赖于很多动态库，所以应当将程序的动态库都拷贝出来，再使用 *core* 文件：

```shell
# gdb main
(gdb) set solib-search-path ./lib
(gdb) core-file core
```

但是有时也会因为 *libc* 等库找不到符号表而堆栈不完全/堆栈异常，如果是使用 *buildroot* 来管理的，这种问题就很好解决：

```shell
# gdb main
(gdb) set sysroot out/staging
(gdb) core-file core
```

 除此之外，就只能通过自己交叉编译调试版的 *libc* 进行辅助定位了。

---

### *breakpad* 使用

#### *breakpad* 编译

*breakpad* 的编译过程如下：

1. 从GitHub上获取到 [*breakpad* 下载链接](https://github.com/google/breakpad) 和 [*lss* 下载链接](https://github.com/adelshokhy112/linux-syscall-support) 。将 *lss* 组件解压后得到的 *lss* 目录放置于 *breakpad* 的 *src/third_party* 中：

   ```shell
   $ tree -L 3
   .
   ├── aclocal.m4
   ...
   ├── configure
   ...
   └── src
       ├── breakpad_googletest_includes.h
      ...
       ├── third_party
       │   ├── curl
       │   ├── libdisasm
       │   ├── linux
       │   ├── lss
       │   ├── mac_headers
       │   └── musl
       └── tools
           ├── linux
           ├── mac
           ├── python
           ├── solaris
           ├── tools.gyp
           └── windows
   
   49 directories, 348 files
   ```

2. 配置：

   ```shell
   # for host
   $ ./configure --prefix=/home/huangkailun/test/breakpad-main/out
   # cross-compile example
   $ ./configure CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ --host=aarch64-linux-gnu --prefix=/home/huangkailun/test/breakpad-main/out
   ```

3. 编译和安装：

   ```shell
   $ make -j 4
   $ make install
   $ tree out/ -L 2
   out/
   ├── bin
   │   ├── core2md
   │   ├── dump_syms
   │   ├── dump_syms_mac
   │   ├── microdump_stackwalk
   │   ├── minidump-2-core
   │   ├── minidump_dump
   │   ├── minidump_stackwalk
   │   ├── minidump_upload
   │   ├── pid2md
   │   └── sym_upload
   ├── include
   │   └── breakpad
   ├── lib
   │   ├── libbreakpad.a
   │   ├── libbreakpad_client.a
   │   └── pkgconfig
   ├── libexec
   │   └── core_handler
   └── share
       └── doc
   
   8 directories, 13 files
   ```

整个过程还是相当顺利的。

#### *breakpad* 应用实例

1. 产生 *minidump* 文件

   ```shell
   [root@a6de0dd8352d test]# cat main.c
   #include <stdio.h>
   #include <stdlib.h>
   #include "client/linux/handler/exception_handler.h"
   
   static bool dumpCallback(const google_breakpad::MinidumpDescriptor& descriptor,
   void* context, bool succeeded) {
     printf("Dump path: %s\n", descriptor.path());
     return succeeded;
   }
   
   void crash() { volatile int* a = (int*)(NULL); *a = 1; }
   
   int main(int argc, char* argv[]) {
     google_breakpad::MinidumpDescriptor descriptor("/tmp");
     google_breakpad::ExceptionHandler eh(descriptor, NULL, dumpCallback, NULL, true, -1);
     crash();
     return 0;
   }
   [root@a6de0dd8352d test]# g++ -g -I./breakpad-main/out/include/breakpad -L./breakpad-main/out/lib main.c -o main -lbreakpad_client -lpthread
   [root@a6de0dd8352d test]# ./main
   Dump path: /tmp/91cfe18e-c066-4fce-9d55fd9a-e94de37f.dmp
   Segmentation fault
   [root@a6de0dd8352d test]# ls
   breakpad-main  main  main.c
   [root@a6de0dd8352d test]# ls /tmp/
   91cfe18e-c066-4fce-9d55fd9a-e94de37f.dmp  ks-script-eusq_sc5
   ks-script-esd4my7v
   [root@a6de0dd8352d test]#
   ```

   使用也很简单，只需要链接 *libbreakpad_client.a* 库，并进行部分函数的调用便可。

2. 使用 *minidump* 文件

   ```shell
   [root@a6de0dd8352d test]# ./breakpad-main/out/bin/dump_syms ./main > main.syms
   [root@a6de0dd8352d test]# ./breakpad-main/out/bin/minidump_stackwalk /tmp/91cfe18e-c066-4fce-9d55fd9a-e94de37f.dmp ./main.syms
   2021-08-14 15:49:24: minidump.cc:5089: INFO: Minidump opened minidump /tmp/91cfe18e-c066-4fce-9d55fd9a-e94de37f.dmp
   2021-08-14 15:49:24: minidump.cc:5219: INFO: Minidump not byte-swapping minidump
   2021-08-14 15:49:24: minidump.cc:5871: INFO: GetStream: type 15 not present
   2021-08-14 15:49:24: minidump.cc:5871: INFO: GetStream: type 1197932545 not present
   2021-08-14 15:49:24: minidump.cc:5871: INFO: GetStream: type 1197932546 not present
   2021-08-14 15:49:24: minidump.cc:2255: INFO: MinidumpModule could not determine version for /home/huangkailun/test/main
   2021-08-14 15:49:24: minidump.cc:2255: INFO: MinidumpModule could not determine version for /usr/lib64/libc.so.6
   ...
   Crash reason:  SIGSEGV /SEGV_MAPERR
   Crash address: 0x0
   Process uptime: not available
   
   Thread 0 (crashed)
    0  main + 0x23bf
       rax = 0x0000000000000000   rdx = 0x000000000061a8a0
       rcx = 0x0000000000000000   rbx = 0x0000000000000000
       rsi = 0x0000000000000000   rdi = 0x000000000061a8a0
       rbp = 0x00007fff08b6ad50   rsp = 0x00007fff08b6ad50
        r8 = 0x0000000000000000    r9 = 0x0000000000d21f88
       r10 = 0x0000000000000007   r11 = 0x00007f5172d7b240
       r12 = 0x0000000000402290   r13 = 0x00007fff08b6b010
       r14 = 0x0000000000000000   r15 = 0x0000000000000000
       rip = 0x00000000004023bf
       Found by: given as instruction pointer in context
    1  main + 0x246b
       rbp = 0x00007fff08b6af30   rsp = 0x00007fff08b6ad60
       rip = 0x000000000040246b
       Found by: previous frame's frame pointer
    2  main + 0x2376
       rbp = 0x00007fff08b6af30   rsp = 0x00007fff08b6ad80
       rip = 0x0000000000402376
       Found by: stack scanning
    3  libc.so.6 + 0x85200
       rbp = 0x00007fff08b6af30   rsp = 0x00007fff08b6aea0
       rip = 0x00007f5172102200
       Found by: stack scanning
   ...
   
   Loaded modules:
   0x00400000 - 0x00419fff  main  ???  (main)  (WARNING: No symbols, main, 7CF5166701FB04D9C359C038FD6C71970)
   0x7f517207d000 - 0x7f5172235fff  libc.so.6  ???  (WARNING: No symbols, libc.so.6, 868DE5AD2A66EECE2210A9EF120187050)
   0x7f5172440000 - 0x7f5172456fff  libgcc_s.so.1  ???
   0x7f5172658000 - 0x7f51727d8fff  libm.so.6  ???
   0x7f51729da000 - 0x7f5172b5ffff  libstdc++.so.6  ???
   0x7f5172d6f000 - 0x7f5172d89fff  libpthread.so.0  ???
   0x7f5172f8f000 - 0x7f5172fb7fff  ld-linux-x86-64.so.2  ???  (WARNING: No symbols, ld-linux-x86-64.so.2, 2B4F5EF978BC839BAADF9BB96C069F030)
   0x7fff08bad000 - 0x7fff08baefff  linux-gate.so  ???
   2021-08-14 15:49:24: minidump.cc:5061: INFO: Minidump closing minidump
   [root@a6de0dd8352d test]# gdb main
   GNU gdb (GDB) Red Hat Enterprise Linux 8.2-15.el8
   Copyright (C) 2018 Free Software Foundation, Inc.
   ...
   Reading symbols from main...done.
   (gdb) l * 0x00000000004023bf
   0x4023bf is in crash() (main.c:11).
   6	void* context, bool succeeded) {
   7	  printf("Dump path: %s\n", descriptor.path());
   8	  return succeeded;
   9	}
   10
   11	void crash() { volatile int* a = (int*)(NULL); *a = 1; }
   12
   13	int main(int argc, char* argv[]) {
   14	  google_breakpad::MinidumpDescriptor descriptor("/tmp");
   15	  google_breakpad::ExceptionHandler eh(descriptor, NULL, dumpCallback, NULL, true, -1);
   (gdb) l * 0x000000000040246b
   0x40246b is in main(int, char**) (main.c:17).
   12
   13	int main(int argc, char* argv[]) {
   14	  google_breakpad::MinidumpDescriptor descriptor("/tmp");
   15	  google_breakpad::ExceptionHandler eh(descriptor, NULL, dumpCallback, NULL, true, -1);
   16	  crash();
   17	  return 0;
   18	}
   (gdb) 
   ```

   使用时，主要通过 *gdb* 来回溯栈的地址，这里主要是指 *rip* 寄存器的值（*ARM* 平台为 *pc* 寄存器），如果需要和 *core* 文件一样查看变量/寄存器的值的情况，则可以使用 *minidump-2-core* ：

   ```shell
   [root@a6de0dd8352d test]# ./breakpad-main/out/bin/minidump-2-core /tmp/2ea6cd8c-fca1-4a75-50d94ea6-653449e7.dmp -o ./minicore
   [root@a6de0dd8352d test]# ls
   breakpad-main  main  main.c  main.core.stackwalk  main.syms  minicore
   [root@a6de0dd8352d test]# gdb main minicore
   GNU gdb (GDB) Red Hat Enterprise Linux 8.2-15.el8
   Copyright (C) 2018 Free Software Foundation, Inc.
   ...
   warning: Unable to find libthread_db matching inferior's thread library, thread debugging will not be available.
   Core was generated by `./main'.
   Program terminated with signal SIGSEGV, Segmentation fault.
   #0  0x00000000004023bf in crash () at main.c:11
   11	void crash() { volatile int* a = (int*)(NULL); *a = 1; }
   Missing separate debuginfos, use: yum debuginfo-install glibc-2.28-127.el8.x86_64 libgcc-8.3.1-5.1.el8.x86_64 libstdc++-8.3.1-5.1.el8.x86_64
   (gdb) bt
   #0  0x00000000004023bf in crash () at main.c:11
   #1  0x000000000040246b in main (argc=1, argv=0x7fff08b6b018) at main.c:16
   (gdb) info locals
   a = 0x0
   (gdb) info registers
   rax            0x0                 0
   rbx            0x0                 0
   rcx            0x0                 0
   rdx            0x61a8a0            6400160
   rsi            0x0                 0
   rdi            0x61a8a0            6400160
   rbp            0x7fff08b6ad50      0x7fff08b6ad50
   rsp            0x7fff08b6ad50      0x7fff08b6ad50
   r8             0x0                 0
   r9             0xd21f88            13770632
   r10            0x7                 7
   r11            0x7f5172d7b240      139987795817024
   r12            0x402290            4203152
   r13            0x7fff08b6b010      140733339578384
   r14            0x0                 0
   r15            0x0                 0
   rip            0x4023bf            0x4023bf <crash()+16>
   eflags         0x10206             [ PF IF RF ]
   cs             0x33                51
   ss             0x0                 0
   ds             0x0                 0
   es             0x0                 0
   fs             0x0                 0
   gs             0x0                 0
   (gdb)
   ```

看到这里，可能很多朋友会觉得奇怪，为什么 *minidump* 文件可以转换为 *core* ，那为什么说它是减少了 *core* 的大小的呢？

那是因为，*minidump* 实际上只存储了崩溃线程堆栈相关的寄存器和堆栈的值，而不是整个进程的 *memory* 全部 *dump*，它首先捕获信号来获取崩溃堆栈，然后启动了子进程，再通过 *ptrace* 来获取崩溃堆栈上的 *memory* 信息，其过程在 `src/client/linux/handler/exception_handler.cc` 文件中通过注释也表示了出来：

```c++
//   SignalHandler (uses a global stack of ExceptionHandler objects to find
//        |         one to handle the signal. If the first rejects it, try
//        |         the second etc...)
//        V
//   HandleSignal ----------------------------| (clones a new process which
//        |                                   |  shares an address space with
//   (wait for cloned                         |  the crashed process. This
//     process)                               |  allows us to ptrace the crashed
//        |                                   |  process)
//        V                                   V
//   (set signal handler to             ThreadEntry (static function to bounce
//    SIG_DFL and rethrow,                    |      back into the object)
//    killing the crashed                     |
//    process)                                V
//                                          DoDump  (writes minidump)
//                                            |
//                                            V
//                                         sys_exit
```

而由于是通过子进程来获取相关信息，且内部封装了内存/系统调用操作，极大程度规避了崩溃后内存信息错乱造成 *dump* 的信息也被破坏等问题发生的风险。



